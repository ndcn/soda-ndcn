#--------------------------------------------------- Omics experiment class ----
Omics_exp = R6::R6Class(
  "Omics_exp",
  public = list(
    initialize = function(name, type = NA, id = NA, slot = NA, preloaded = F, param_file = NULL){
      self$name = name
      self$type = type
      self$id = id
      self$slot = slot
      self$preloaded_data = preloaded

      if (!is.null(param_file)) {
        if (file.exists(param_file)){
          tryCatch({
            params = base::dget(param_file)
            # Regular params
            for (p1 in names(params$params)) {
              if (p1 %in% names(self$params)){
                for (p2 in names(params$params[[p1]])){
                  if (p2 %in% names(self$params[[p1]])){
                    self$params[[p1]][[p2]] = params$params[[p1]][[p2]]
                  }
                }
              }
            }

            # Settings
            for (p1 in names(params$hardcoded_settings)) {
              if (p1 %in% names(self$hardcoded_settings)){
                for (p2 in names(params$hardcoded_settings[[p1]])) {
                  if (p2 %in% names(self$hardcoded_settings[[p1]])) {
                    self$hardcoded_settings[[p1]][[p2]] = params$hardcoded_settings[[p1]][[p2]]
                  }
                }
              }
            }
          },
          error = function(e) {
            message("Error in reading the parameter file, default parameters kept: ", e$message)
          })
        }
      }
    },
    #--------------------------------------------------------------- Global ----
    name = NA,
    id = NA,
    slot = NA,
    type = NA,
    preloaded_data = F,

    #----------------------------------------------------------- Parameters ----
    params = list(
      # Class distribution parameters
      class_distribution = list(
        dataset = 'Class table total normalized',
        group_col = NULL,
        color_palette = 'Spectral',
        img_format = "png"
      ),

      # Class comparison parameters
      class_comparison = list(
        dataset = 'Class table total normalized',
        group_col = NULL,
        color_palette = 'Spectral',
        img_format = "png"
      ),

      # Volcano plot parameters self$params$volcano_plot$
      volcano_plot = list(
        auto_refresh = T,
        data_table = 'Total normalized table',
        adjustment = "BH",
        group_col = NULL,
        group_1 = NULL,
        group_2 = NULL,
        feature_metadata = 'None',
        keep_significant = F,
        displayed_plot = 'main',
        p_val_threshold = 0.05,
        fc_threshold = 2,
        marker_size = 6,
        opacity = 1,
        color_palette = 'Spectral',
        selected_function = "mean",
        selected_test = "t-Test",
        img_format = "png"
      ),

      # Heatmap parameters self$params$heatmap$
      heatmap = list(
        auto_refresh = T,
        dataset = 'Z-scored total normalized table',
        impute = T,
        cluster_samples = T,
        cluster_features = T,
        map_sample_data = NULL,
        map_feature_data = NULL,
        map_feature_terms = NULL,
        multival_cols = 'None',
        group_column_da = NULL,
        apply_da = T,
        alpha_da = 0.8,
        lock_da = T,
        color_palette = 'RdYlBu',
        reverse_palette = F,
        img_format = "png"
      ),

      # samples correlation parameters self$params$samples_correlation$
      samples_correlation = list(
        auto_refresh = T,
        dataset = 'Z-scored total normalized table',
        correlation_method = "pearson",
        use = 'pairwise.complete.obs',
        cluster_cols = T,
        cluster_rows = T,
        row_annotations = 'Group_type',
        col_annotations = 'Group_type',
        color_palette = 'RdYlBu',
        reverse_palette = F,
        img_format = "png"
      ),

      # feature_correlation parameters self$params$feature_correlation$
      feature_correlation = list(
        auto_refresh = T,
        dataset = 'Z-scored total normalized table',
        multival_cols = 'None',
        map_feature_terms = NULL,
        correlation_method = "pearson",
        use = 'pairwise.complete.obs',
        cluster_cols = T,
        cluster_rows = T,
        row_annotations = NULL,
        col_annotations = NULL,
        roh_threshold = 0.95,
        top_features = 300,
        color_palette = 'RdYlBu',
        reverse_palette = F,
        img_format = "png"
      ),

      # PCA parameters self$params$pca$
      pca = list(
        auto_refresh = T,
        data_table = 'z_scored_total_norm_data',
        sample_groups_col = NULL,
        feature_groups_col = NULL,
        apply_da = FALSE,
        alpha_da = 0.8,
        pca_method = 'svd',
        nPcs = 10,
        displayed_pc_1 = 1,
        displayed_pc_2 = 2,
        completeObs = F,
        displayed_plots = 'both',
        colors_palette = 'Spectral',
        img_format = "png"
      ),


      # Double bonds parameters self$params$db_plot$
      db_plot = list(
        dataset = "Total normalized table",
        adjustment = "Benjamini-Hochberg",
        group_column = NULL,
        selected_groups = NULL,
        selected_lipid_class = NULL,
        selected_carbon_chain = 'Carbon count (chain 1)',
        selected_unsat = 'Double bonds (chain 1)',
        selected_function = "mean",
        selected_test = "T-test",
        fc_range = c(-5, 5),
        fc_values = c(-1, 1),
        pval_range = c(0, 5),
        pval_values = c(1, 5),
        img_format = "png"
      ),

      #GSEA parameters self$params$gsea
      gsea = list(
        data_table = NULL,
        meta_table = NULL,
        group_col = NULL,
        groups = NULL,
        used_function = NULL,
        test = NULL,
        p_value_cutoff_prep = NULL,
        prot_list = NULL,
        ont = NULL,
        minGSSize = NULL,
        maxGSSize = NULL,
        p_value_cutoff = NULL,
        verbose = NULL,
        OrgDb = NULL,
        pAdjustMethod = NULL,
        termsim_method = NULL,
        termsim_showcat = NULL
      ),

      # Over representation analysis parameters self$params$overrepresentation
      overrepresentation = list(
        pval_cutoff_features = 0.05,
        padjust_features = "Benjamini-Hochberg",
        pval_cutoff = 0.05,
        pAdjustMethod = "BH",
        fc_threshold = 2,
        ont = "Gene ontology (ALL)",
        qval_cutoff = 0.05,
        minGSSize = 10,
        maxGSSize = 500
      ),

      # Dot plot parameters self$params$dot_plot
      dot_plot = list(
        showCategory = 10,
        mode = "Both",
        img_format = "png"
      ),

      # Ridge plot parameters self$params$ridge_plot
      ridge_plot = list(
        showCategory = 30,
        img_format = "png"
      ),

      # CNET plot parameters self$params$cnet_plot
      cnet_plot = list(
        showCategory = 3,
        displayed_labels = 'IDs and Description',
        enable_physics = TRUE
      ),

      # eMap plot parameters self$params$emap_plot
      emap_plot = list(
        showCategory = 20,
        color = "p.adjust" ,
        size = "Count",
        score_threshold = 0.2,
        similarity_score = 'JC',
        edge_magnifier = 1,
        node_magnifier = 0.1,
        enable_physics = FALSE
      ),

      # Over representation dot plot parameters self$params$or_dot_plot
      or_dot_plot = list(
        showCategory = 10,
        img_format = "png"
      ),

      # Over representation bar plot parameters self$params$or_bar_plot
      or_bar_plot = list(
        x = 'Count',
        color = 'p.adjust',
        showCategory = 10,
        img_format = "png"
      ),

      # Over representation CNET plot parameters self$params$or_cnet_plot
      or_cnet_plot = list(
        showCategory = 3,
        displayed_labels = 'IDs and Description',
        enable_physics = TRUE
      ),

      # Over representation eMap plot parameters self$params$or_emap_plot
      or_emap_plot = list(
        showCategory = 20,
        color = "p.adjust" ,
        size = "Count",
        score_threshold = 0.2,
        similarity_score = 'JC',
        edge_magnifier = 1,
        node_magnifier = 0.1,
        enable_physics = FALSE
      )

    ),

    hardcoded_settings = list(

      volcano_plot = list(
        datasets = list(
          "Raw data table",
          "Class normalized table",
          "Total normalized table"
        )
      ),
      heatmap = list(
        datasets = list(
          'Z-scored table',
          'Z-scored total normalized table',
          'Class table z-scored'
        )
      ),
      samples_correlation = list(
        datasets = list(
          "Raw data table",
          "Total normalized table",
          'Z-scored table',
          'Z-scored total normalized table'
        )
      ),
      feature_correlation = list(
        datasets = list(
          "Raw data table",
          "Total normalized table",
          'Z-scored table',
          'Z-scored total normalized table'
        )
      ),

      pca = list(
        datasets = list(
          'Z-scored table',
          'Z-scored total normalized table'
        )
      ),
      db_plot = list(
        datasets = list(
          "Raw data table",
          "Class normalized table",
          "Total normalized table"
        )
      ),

      enrichment_analysis = list(
        terms = c('Gene ontology (ALL)',
                  'Gene ontology (BP)',
                  'Gene ontology (MF)',
                  'Gene ontology (CC)'),
        adjustment = c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")
      ),
      over_representation_analysis = list(
        terms = c('Gene ontology (ALL)',
                  'Gene ontology (BP)',
                  'Gene ontology (MF)',
                  'Gene ontology (CC)'),
        adjustment = c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")
      )
    ),



    #--------------------------------------------------------------- Indices ----

    indices = list(
      id_col_meta = NA,
      id_col_data = NA,
      type_col = NA,
      group_col = NA,
      batch_col = NA,

      idx_blanks = NULL,
      idx_qcs = NULL,
      idx_pools = NULL,
      idx_samples = NULL,

      rownames_blanks = NULL,
      rownames_qcs = NULL,
      rownames_pools = NULL,
      rownames_samples = NULL,

      excluded_cols = NULL,

      feature_id_type = NULL
    ),

    #--------------------------------------------------------------- Tables ----

    tables = list(

      imp_meta = NULL,
      raw_meta = NULL,

      imp_data = NULL,
      raw_data = NULL,

      blank_table = NULL,

      #Feature tables
      imp_feature_table = NULL,
      feature_table = NULL,
      feature_list = NULL,

      # External feature tables
      external_feature_tables = list(),

      # External feature tables
      external_enrichment_tables = list(),

      # Group summaries
      summary_species_table = NULL,
      summary_class_table = NULL,

      # Normalised
      class_norm_data = NULL,
      total_norm_data = NULL,

      # Z-scored
      z_scored_data = NULL,
      z_scored_class_norm_data = NULL,
      z_scored_total_norm_data = NULL,

      # class tables
      class_table= NULL,
      class_table_z_scored = NULL,
      class_table_total_norm = NULL,
      class_table_z_scored_total_norm = NULL,

      # Plot tables
      class_distribution_table = NULL,
      volcano_table = NULL,
      heatmap_table = NULL,
      samples_correlation = NULL,
      feature_correlation = NULL,
      pca_scores_table = NULL,
      pca_loadings_table = NULL,
      dbplot_table = NULL,

      # GSEA & over representation
      gsea_prot_list = NULL,
      ora_prot_list = NULL,
      gsea_object = NULL,
      go_enrich = NULL


    ),

    #-------------------------------------------------------------- Local table

    table_switch_local = function(table_name) {
      switch(EXPR = table_name,
             'Imported metadata table' = self$tables$imp_meta,
             'Raw metadata table' = self$tables$raw_meta,
             'Imported data table' = self$tables$imp_data,
             'Raw data table' = self$tables$raw_data,
             'Feature table' = self$tables$feature_table,
             'Blank table' = self$tables$blank_table,
             'Class normalized table' = self$tables$class_norm_data,
             'Total normalized table' = self$tables$total_norm_data,
             'Z-scored table' = self$tables$z_scored_data,
             'Z-scored class normalized table' = self$tables$z_scored_class_norm_data,
             'Z-scored total normalized table' = self$tables$z_scored_total_norm_data,
             'Class table' = self$tables$class_table,
             'Class table z-scored' = self$tables$class_table_z_scored,
             'Class table total normalized' = self$tables$class_table_total_norm,
             'Class table z-scored total normalized' = self$tables$class_table_z_scored_total_norm,
             'Species summary table' = self$tables$summary_species_table,
             'Class summary table' = self$tables$summary_class_table,
             'GSEA prot list' = self$tables$gsea_prot_list,
             'ORA prot list' = self$tables$ora_prot_list
      )
    },

    table_check_convert = function(table) {
      if (length(table) == 1) {
        if (is.character(table)){
          table = self$table_switch_local(table)
        }
      }
      return(table)
    },

    #---------------------------------------------------------------- Plots ----
    plots = list(

      # Interactive visualization
      class_distribution = NULL,
      class_comparison = NULL,
      volcano_plot = NULL,
      heatmap = NULL,
      samples_correlation = NULL,
      feature_correlation = NULL,
      pca_plot = NULL,
      double_bond_plot = NULL,

      # Functional analysis plots
      dotplot = NULL,
      ridgeplot = NULL,
      emap_plot = NULL,
      cnetplot = NULL,
      or_dotplot = NULL,
      or_emap_plot = NULL,
      or_cnetplot = NULL,
      or_barplot = NULL
    ),

    #---------------------------------------------------- Parameter methods ----

    export_params= function(file_name) {
      parameter_file = list(params = self$params,
                            hardcoded_settings = self$hardcoded_settings)
      base::dput(parameter_file, file = file_name)
    },

    param_class_distribution = function(dataset, group_col, color_palette, img_format) {
      self$params$class_distribution$dataset = dataset
      self$params$class_distribution$group_col = group_col
      self$params$class_distribution$color_palette = color_palette
      self$params$class_distribution$img_format = img_format
    },

    param_class_comparison = function(dataset, group_col, color_palette, img_format) {
      self$params$class_comparison$dataset = dataset
      self$params$class_comparison$group_col = group_col
      self$params$class_comparison$color_palette = color_palette
      self$params$class_comparison$img_format = img_format
    },

    param_volcano_plot = function(auto_refresh, data_table, adjustment, group_col, group_1, group_2, feature_metadata, keep_significant, displayed_plot,
                                  p_val_threshold, fc_threshold, marker_size, opacity, color_palette, selected_function, selected_test, img_format) {

      self$params$volcano_plot$auto_refresh = auto_refresh
      self$params$volcano_plot$data_table = data_table
      self$params$volcano_plot$adjustment = adjustment
      self$params$volcano_plot$group_col = group_col
      self$params$volcano_plot$group_1 = group_1
      self$params$volcano_plot$group_2 = group_2
      self$params$volcano_plot$feature_metadata = feature_metadata
      self$params$volcano_plot$keep_significant = keep_significant
      self$params$volcano_plot$displayed_plot = displayed_plot
      self$params$volcano_plot$p_val_threshold = p_val_threshold
      self$params$volcano_plot$fc_threshold = fc_threshold
      self$params$volcano_plot$marker_size = marker_size
      self$params$volcano_plot$opacity = opacity
      self$params$volcano_plot$color_palette = color_palette
      self$params$volcano_plot$selected_function = selected_function
      self$params$volcano_plot$selected_test = selected_test
      self$params$volcano_plot$img_format = img_format

    },

    param_heatmap = function(auto_refresh, dataset, impute, cluster_samples, cluster_features, map_sample_data, map_feature_data, map_feature_terms, multival_cols, group_column_da, apply_da, alpha_da, color_palette, reverse_palette, img_format) {
      self$params$heatmap$auto_refresh = auto_refresh
      self$params$heatmap$dataset = dataset
      self$params$heatmap$impute = impute
      self$params$heatmap$cluster_samples = cluster_samples
      self$params$heatmap$cluster_features = cluster_features
      self$params$heatmap$map_sample_data = map_sample_data
      self$params$heatmap$map_feature_data = map_feature_data
      self$params$heatmap$map_feature_terms = map_feature_terms
      self$params$heatmap$multival_cols = multival_cols
      self$params$heatmap$group_column_da = group_column_da
      self$params$heatmap$apply_da = apply_da
      self$params$heatmap$alpha_da = alpha_da
      self$params$heatmap$color_palette = color_palette
      self$params$heatmap$reverse_palette = reverse_palette
      self$params$heatmap$img_format = img_format
    },

    param_samples_correlation = function(auto_refresh, dataset, correlation_method, use, cluster_rows, cluster_cols, row_annotations, col_annotations, color_palette, reverse_palette, img_format) {
      self$params$samples_correlation$auto_refresh = auto_refresh
      self$params$samples_correlation$dataset = dataset
      self$params$samples_correlation$correlation_method = correlation_method
      self$params$samples_correlation$use = use
      self$params$samples_correlation$cluster_rows = cluster_rows
      self$params$samples_correlation$cluster_cols = cluster_cols
      self$params$samples_correlation$row_annotations = row_annotations
      self$params$samples_correlation$col_annotations = col_annotations
      self$params$samples_correlation$color_palette = color_palette
      self$params$samples_correlation$reverse_palette = reverse_palette
      self$params$samples_correlation$img_format = img_format
    },

    param_feature_correlation = function(auto_refresh, dataset, multival_cols, map_feature_terms, correlation_method, use, cluster_cols, cluster_rows, row_annotations, col_annotations, roh_threshold, top_features, color_palette, reverse_palette, img_format) {

      self$params$feature_correlation$auto_refresh = auto_refresh
      self$params$feature_correlation$dataset = dataset
      self$params$feature_correlation$multival_cols = multival_cols
      self$params$feature_correlation$map_feature_terms = map_feature_terms
      self$params$feature_correlation$correlation_method = correlation_method
      self$params$feature_correlation$use = use
      self$params$feature_correlation$cluster_cols = cluster_cols
      self$params$feature_correlation$cluster_rows = cluster_rows
      self$params$feature_correlation$row_annotations = row_annotations
      self$params$feature_correlation$col_annotations = col_annotations
      self$params$feature_correlation$roh_threshold = roh_threshold
      self$params$feature_correlation$top_features = top_features
      self$params$feature_correlation$color_palette = color_palette
      self$params$feature_correlation$reverse_palette = reverse_palette
      self$params$feature_correlation$img_format = img_format
    },

    param_pca = function(auto_refresh, data_table, sample_groups_col, feature_groups_col, apply_da, alpha_da, pca_method, nPcs, displayed_pc_1, displayed_pc_2, completeObs, displayed_plots, colors_palette, img_format) {
      self$params$pca$auto_refresh = auto_refresh
      self$params$pca$data_table = data_table
      self$params$pca$sample_groups_col = sample_groups_col
      self$params$pca$feature_groups_col = feature_groups_col
      self$params$pca$apply_da = apply_da
      self$params$pca$alpha_da = alpha_da
      self$params$pca$pca_method = pca_method
      self$params$pca$nPcs = nPcs
      self$params$pca$displayed_pc_1 = displayed_pc_1
      self$params$pca$displayed_pc_2 = displayed_pc_2
      self$params$pca$completeObs = completeObs
      self$params$pca$displayed_plots = displayed_plots
      self$params$pca$colors_palette = colors_palette
      self$params$pca$img_format = img_format

    },

    param_db_plot = function(dataset, adjustment, group_column, selected_groups, selected_lipid_class,
                             selected_carbon_chain, selected_unsat, selected_function,
                             selected_test, fc_range, fc_values, pval_range,
                             pval_values, img_format) {

      self$params$db_plot$dataset = dataset
      self$params$db_plot$adjustment = adjustment
      self$params$db_plot$group_column = group_column
      self$params$db_plot$selected_groups = selected_groups
      self$params$db_plot$selected_lipid_class = selected_lipid_class
      self$params$db_plot$selected_carbon_chain = selected_carbon_chain
      self$params$db_plot$selected_unsat = selected_unsat
      self$params$db_plot$selected_function = selected_function
      self$params$db_plot$selected_test = selected_test
      self$params$db_plot$fc_range = fc_range
      self$params$db_plot$fc_values = fc_values
      self$params$db_plot$pval_range = pval_range
      self$params$db_plot$pval_values = pval_values
      self$params$db_plot$img_format = img_format

    },

    param_gsea = function(data_table, meta_table, group_col, groups, used_function, test,
                          p_value_cutoff_prep, prot_list, ont, minGSSize, maxGSSize, p_value_cutoff,
                          verbose, OrgDb, pAdjustMethod, termsim_method, termsim_showcat) {
      self$params$gsea$data_table = data_table
      self$params$gsea$meta_table = meta_table
      self$params$gsea$group_col = group_col
      self$params$gsea$groups = groups
      self$params$gsea$used_function = used_function
      self$params$gsea$test = test
      self$params$gsea$p_value_cutoff_prep = p_value_cutoff_prep
      self$params$gsea$prot_list = prot_list
      self$params$gsea$ont = ont
      self$params$gsea$minGSSize = minGSSize
      self$params$gsea$maxGSSize = maxGSSize
      self$params$gsea$p_value_cutoff = p_value_cutoff
      self$params$gsea$verbose = verbose
      self$params$gsea$OrgDb = OrgDb
      self$params$gsea$pAdjustMethod = pAdjustMethod
      self$params$gsea$termsim_method = termsim_method
      self$params$gsea$termsim_showcat = termsim_showcat
    },

    param_overrepresentation = function(pval_cutoff_features, padjust_features, pval_cutoff, fc_threshold,
                                        pAdjustMethod, ont, qval_cutoff, minGSSize, maxGSSize) {
      self$params$overrepresentation$pval_cutoff_features = pval_cutoff_features
      self$params$overrepresentation$padjust_features = padjust_features
      self$params$overrepresentation$pval_cutoff = pval_cutoff
      self$params$overrepresentation$pAdjustMethod = pAdjustMethod
      self$params$overrepresentation$fc_threshold = fc_threshold
      self$params$overrepresentation$ont = ont
      self$params$overrepresentation$qval_cutoff = qval_cutoff
      self$params$overrepresentation$minGSSize = minGSSize
      self$params$overrepresentation$maxGSSize = maxGSSize

    },

    param_dot_plot = function(showCategory, mode, img_format) {
      self$params$dot_plot$showCategory = showCategory
      self$params$dot_plot$mode = mode
      self$params$dot_plot$img_format = img_format
    },

    param_ridge_plot = function(showCategory, img_format) {
      self$params$ridge_plot$showCategory = showCategory
      self$params$ridge_plot$img_format = img_format
    },

    param_cnet_plot = function(showCategory, displayed_labels, enable_physics) {
      self$params$cnet_plot$showCategory = showCategory
      self$params$cnet_plot$displayed_labels = displayed_labels
      self$params$cnet_plot$enable_physics = enable_physics
    },

    param_emap_plot = function(showCategory, color, size, score_threshold, similarity_score, edge_magnifier, node_magnifier, enable_physics) {
      self$params$emap_plot$showCategory = showCategory
      self$params$emap_plot$color = color
      self$params$emap_plot$size = size
      self$params$emap_plot$score_threshold = score_threshold
      self$params$emap_plot$similarity_score = similarity_score
      self$params$emap_plot$edge_magnifier = edge_magnifier
      self$params$emap_plot$node_magnifier = node_magnifier
      self$params$emap_plot$enable_physics = enable_physics
    },

    param_or_dot_plot = function(showCategory, img_format) {
      self$params$or_dot_plot$showCategory = showCategory
      self$params$or_dot_plot$img_format = img_format
    },

    param_or_bar_plot = function(x, color, showCategory, img_format) {
      self$params$or_bar_plot$x = x
      self$params$or_bar_plot$color = color
      self$params$or_bar_plot$showCategory = showCategory
      self$params$or_bar_plot$img_format = img_format
    },

    param_or_cnet_plot = function(showCategory, displayed_labels, enable_physics) {
      self$params$or_cnet_plot$showCategory = showCategory
      self$params$or_cnet_plot$displayed_labels = displayed_labels
      self$params$or_cnet_plot$enable_physics = enable_physics
    },

    param_or_emap_plot = function(showCategory, color, size, score_threshold, similarity_score, edge_magnifier, node_magnifier, enable_physics) {
      self$params$or_emap_plot$showCategory = showCategory
      self$params$or_emap_plot$color = color
      self$params$or_emap_plot$size = size
      self$params$or_emap_plot$score_threshold = score_threshold
      self$params$or_emap_plot$similarity_score = similarity_score
      self$params$or_emap_plot$edge_magnifier = edge_magnifier
      self$params$or_emap_plot$node_magnifier = node_magnifier
      self$params$or_emap_plot$enable_physics = enable_physics
    },


    #-------------------------------------------------------- Table methods ----

    set_raw_meta = function(){

      if (!is.na(self$indices$id_col_meta) & !is.null(self$tables$imp_meta)){
        data_table = self$tables$imp_meta
        rownames(data_table) = data_table[,self$indices$id_col_meta]
        data_table[,self$indices$id_col_meta] = NULL
        self$tables$raw_meta = data_table
      }
    },

    set_raw_data = function(apply_imputation = T,
                            impute_before = T,
                            apply_filtering = T,
                            imputation_function = 'median',
                            val_threshold = 0.6,
                            blank_multiplier = 0.8,
                            sample_threshold = 0.8,
                            group_threshold = 0.8,
                            norm_col = "") {

      if (!is.na(self$indices$id_col_data) & !is.null(self$tables$imp_data) & !is.null(self$tables$raw_meta)){

        # Copy imported table
        data_table = self$tables$imp_data

        # Set ID column
        rownames(data_table) = data_table[,self$indices$id_col_data]
        data_table[,self$indices$id_col_data] = NULL
        data_table = as.matrix(data_table)

        # Keep only rows from raw_meta
        data_table = data_table[rownames(self$tables$raw_meta),]

        # Remove columns from exclusion list
        if (!is.null(self$indices$excluded_cols)) {
          data_table = drop_cols(data_table, self$indices$excluded_cols)
        }

        # Remove empty columns
        data_table = remove_empty_cols(data_table)

        # Imputation and filtering
        if (apply_imputation & impute_before & apply_filtering) {
          data_table = impute_na(method = imputation_function,
                                 data_table = data_table,
                                 meta_table = self$tables$raw_meta,
                                 group_col = self$indices$group_col,
                                 sample_rownames = self$indices$rownames_samples,
                                 val_threshold = val_threshold)

          del_cols = lips_get_del_cols(data_table = data_table,
                                       blank_table = self$tables$blank_table,
                                       imp_meta = self$tables$imp_meta,
                                       raw_meta = self$tables$raw_meta,
                                       idx_blanks = self$indices$idx_blanks,
                                       idx_samples = self$indices$idx_samples,
                                       id_col_meta = self$indices$id_col_meta,
                                       group_col = self$indices$group_col,
                                       batch_col = self$indices$batch_col,
                                       blank_multiplier = blank_multiplier,
                                       sample_threshold = sample_threshold,
                                       group_threshold = group_threshold)

          data_table = drop_cols(data_table, del_cols)

        } else if (apply_imputation & !impute_before & apply_filtering) {
          del_cols = lips_get_del_cols(data_table = data_table,
                                       blank_table = self$tables$blank_table,
                                       imp_meta = self$tables$imp_meta,
                                       raw_meta = self$tables$raw_meta,
                                       idx_blanks = self$indices$idx_blanks,
                                       idx_samples = self$indices$idx_samples,
                                       id_col_meta = self$indices$id_col_meta,
                                       group_col = self$indices$group_col,
                                       batch_col = self$indices$batch_col,
                                       blank_multiplier = blank_multiplier,
                                       sample_threshold = sample_threshold,
                                       group_threshold = group_threshold)

          data_table = drop_cols(data_table, del_cols)

          data_table = impute_na(method = imputation_function,
                                 data_table = data_table,
                                 meta_table = self$tables$raw_meta,
                                 group_col = self$indices$group_col,
                                 sample_rownames = self$indices$rownames_samples,
                                 val_threshold = val_threshold)
        } else if (apply_imputation & !apply_filtering) {
          data_table = impute_na(method = imputation_function,
                                 data_table = data_table,
                                 meta_table = self$tables$raw_meta,
                                 group_col = self$indices$group_col,
                                 sample_rownames = self$indices$rownames_samples,
                                 val_threshold = val_threshold)
        } else if (!apply_imputation & apply_filtering) {
          # Filtering alone
          del_cols = lips_get_del_cols(data_table = data_table,
                                       blank_table = self$tables$blank_table,
                                       imp_meta = self$tables$imp_meta,
                                       raw_meta = self$tables$raw_meta,
                                       idx_blanks = self$indices$idx_blanks,
                                       idx_samples = self$indices$idx_samples,
                                       id_col_meta = self$indices$id_col_meta,
                                       group_col = self$indices$group_col,
                                       batch_col = self$indices$batch_col,
                                       blank_multiplier = blank_multiplier,
                                       sample_threshold = sample_threshold,
                                       group_threshold = group_threshold)

          data_table = drop_cols(data_table, del_cols)
        }

        if (norm_col != "") {
          if (is_num_coercible(self$tables$raw_meta[,norm_col]) & !base::any(is.na(self$tables$raw_meta[,norm_col]))) {
            print(paste0('Normalizing data by ', norm_col))
            data_table = data_table/as.numeric(self$tables$raw_meta[,norm_col])
          } else {
            print('Warning: Normalization skipped, selected column contains either non numeric or missing data.')
          }
        }
        self$tables$raw_data = data_table
      }
    },

    add_go_data = function(name,
                           feature_names,
                           keyType,
                           ont,
                           pvalueCutoff) {
      go_data = annotate_go(feature_names = feature_names,
                            keyType = keyType,
                            ont = ont,
                            pvalueCutoff = pvalueCutoff)

      if (is.null(go_data)) {
        print('No GO enrichment with used parameters.')
        return()
      }

      sparse_table = get_sparse_matrix(features_go_table = go_data$feature_table,
                                       all_go_terms = rownames(go_data$go_table),
                                       sep = '|')

      self$tables$external_enrichment_tables[[name]]$terms_table = go_data$go_table
      self$tables$external_enrichment_tables[[name]]$association_table = go_data$feature_table
      self$tables$external_enrichment_tables[[name]]$sparse_table = sparse_table
    },

    upload_enrichment_data = function(name,
                                      association_table,
                                      terms_table = NULL,
                                      sep = '|') {

      # Create terms table if null
      if (is.null(terms_table)) {
        go_list = vector("list", nrow(association_table))
        # Loop through each row and split the 'go_terms' column by '|'
        for (i in 1:nrow(association_table)) {
          if (is.na(association_table[i,1])) {
            next
          } else {
            go_list[[i]] = strsplit(as.character(association_table[i,1]), sep, fixed = TRUE)[[1]]
          }
        }
        go_list = sort(unique(unlist(go_list)))
        terms_table = data.frame(
          ID = go_list,
          Description = go_list
        )
        rownames(terms_table) = terms_table$ID
        terms_table$ID = NULL
      }
      sparse_matrix = get_sparse_matrix(features_go_table = association_table[1],
                                        all_go_terms = rownames(terms_table),
                                        sep = sep)

      self$tables$external_enrichment_tables[[name]]$terms_table = terms_table
      self$tables$external_enrichment_tables[[name]]$association_table = association_table
      self$tables$external_enrichment_tables[[name]]$sparse_table = sparse_matrix

    },

    del_go_data = function(name) {
      self$tables$external_enrichment_tables[[name]] = NULL
      if (length(names(self$tables$external_enrichment_tables)) == 0) {
        names(self$tables$external_enrichment_tables) = NULL
      }
    },

    get_feature_table = function() {
      data_table = self$tables$imp_data
      data_table = data_table[,2:ncol(data_table)]
      self$tables$imp_feature_table = get_feature_metadata(data_table = data_table, dtype = base::tolower(self$type))
    },

    update_feature_table = function(sep = "|") {
      if (sep == "|") {
        regex_sep = "\\|"
      } else {
        regex_sep = sep
      }
      feature_table = self$tables$imp_feature_table[colnames(self$tables$raw_data),,drop = F]
      ext_names = names(self$tables$external_feature_tables)
      for (name in ext_names) {
        feature_table = augment_feature_table(feature_table = feature_table,
                                              external_table_name = name,
                                              external_feature_table = self$tables$external_feature_tables[[name]])
      }

      multi_value_annotations = sapply(feature_table, function(column) sum(stringr::str_count(column, regex_sep), na.rm = T))
      multi_value_annotations[is.na(multi_value_annotations)] = 0
      feature_table[feature_table == ""] = NA
      non_missing_counts = sapply(feature_table, function(column) sum(!is.na(column)))
      multi_value_annotations = names(multi_value_annotations)[multi_value_annotations > non_missing_counts]

      out_list = vector('list', length(multi_value_annotations))
      names(out_list) = multi_value_annotations

      for (col in multi_value_annotations) {
        feature_list = vector("list", nrow(feature_table))
        for (i in 1:nrow(feature_table)) {
          if (is.na(feature_table[i,col])) {
            next
          } else {
            feature_list[[i]] = strsplit(as.character(feature_table[i,col]), sep, fixed = TRUE)[[1]]
          }
        }
        feature_list = sort(unique(unlist(feature_list)))
        sparse_matrix = get_sparse_matrix(features_go_table = feature_table[col],
                                          all_go_terms = feature_list,
                                          sep = sep)
        out_list[[col]]$feature_list = feature_list
        out_list[[col]]$sparse_matrix = sparse_matrix
      }

      self$tables$feature_table = feature_table
      self$tables$feature_list = out_list
    },

    add_feature_table = function(name, feature_file) {
      ext_feature_table = soda_read_table(file_path = feature_file,
                                          sep = NA,
                                          first_column_as_index = T)
      self$tables$external_feature_tables[[name]] = ext_feature_table
    },

    del_feature_table = function(name) {
      self$tables$external_feature_tables[[name]] = NULL
      if (length(names(self$tables$external_feature_tables)) == 0) {
        names(self$tables$external_feature_tables) = NULL
      }
    },

    get_blank_table = function() {
      blank_idx = which(self$tables$imp_data[,self$indices$id_col_meta] %in% self$tables$imp_meta[self$indices$idx_blanks,self$indices$id_col_data])
      blank_table = self$tables$imp_data[blank_idx,]
      rownames(blank_table) = blank_table[,self$indices$id_col_data]
      blank_table[,self$indices$id_col_data] = NULL
      self$tables$blank_table = as.matrix(blank_table)
    },

    # Class normalisation
    normalise_class = function(){
      self$tables$class_norm_data = normalise_lipid_class(self$tables$raw_data)
    },

    # Total or Row normalisation
    normalise_total = function(){
      self$tables$total_norm_data = self$tables$raw_data/rowSums(self$tables$raw_data, na.rm = T)
    },

    # Z-score normalisation
    normalise_z_score = function() {
      self$tables$z_scored_data = z_score_normalisation(data_table = self$tables$raw_data)
    },

    # Class and z-score normalisation
    normalise_class_z_score = function() {
      self$tables$z_scored_class_norm_data = z_score_normalisation(data_table = self$tables$class_norm_data)
    },

    # Total and z-score normalisation
    normalise_total_z_score = function() {
      self$tables$z_scored_total_norm_data = z_score_normalisation(data_table = self$tables$total_norm_data)
    },

    # Class table
    get_class_table = function(){
      self$tables$class_table = get_lipid_class_table(self$tables$raw_data)
    },

    # Class table z-scored
    get_class_table_z_scored = function(){
      self$tables$class_table_z_scored = z_score_normalisation(data_table = self$tables$class_table)
    },

    # Class table total norm
    class_grouping_total_norm = function(){
      self$tables$class_table_total_norm = get_lipid_class_table(self$tables$total_norm_data)
    },

    # Z-score the class table (generated by the class_grouping method)
    normalise_class_table_z_score = function() {
      self$tables$class_table_z_scored_total_norm = z_score_normalisation(data_table = self$tables$class_table_total_norm)
    },

    get_group_summary_species = function() {
      self$tables$summary_species_table = get_group_median_table(data_table = self$tables$raw_data,
                                                                 meta_table = self$tables$raw_meta,
                                                                 group_col = self$indices$group_col)
    },

    get_group_summary_classes = function() {
      self$tables$summary_class_table = get_group_median_table(data_table = self$tables$class_table,
                                                               meta_table = self$tables$raw_meta,
                                                               group_col = self$indices$group_col)
    },

    derive_data_tables = function(params_list) {
      # Derive tables
      self$get_feature_table()
      self$update_feature_table()
      self$normalise_total()
      self$normalise_z_score()
      self$normalise_total_z_score()
      self$get_group_summary_species()

      if (self$type == "Lipidomics") {
        self$normalise_class()
        self$normalise_class_z_score()
        self$get_class_table()
        self$get_class_table_z_scored()
        self$class_grouping_total_norm()
        self$normalise_class_table_z_score()
        self$get_group_summary_classes()
      }

      # Set plotting parameters
      self$indices$feature_id_type = 'SYMBOL'

      self$param_class_distribution(dataset = 'Class table total normalized',
                                    group_col = self$indices$group_col,
                                    color_palette = 'Spectral',
                                    img_format = "png")

      self$param_class_comparison(dataset = 'Class table total normalized',
                                  group_col = self$indices$group_col,
                                  color_palette = 'Spectral',
                                  img_format = "png")

      self$param_pca(auto_refresh = T,
                     data_table = 'z_scored_total_norm_data',
                     sample_groups_col = self$indices$group_col,
                     feature_groups_col = NULL,
                     apply_da = FALSE,
                     alpha_da = 0.8,
                     pca_method = 'svd',
                     nPcs = 10,
                     displayed_pc_1 = 1,
                     displayed_pc_2 = 2,
                     completeObs = F,
                     displayed_plots = 'both',
                     colors_palette = 'Spectral',
                     img_format = "png")

      self$param_volcano_plot(auto_refresh = T,
                              data_table = 'Total normalized table',
                              adjustment = "BH",
                              group_col = self$indices$group_col,
                              group_1 = unique(self$tables$raw_meta[,self$indices$group_col])[1],
                              group_2 = unique(self$tables$raw_meta[,self$indices$group_col])[2],
                              feature_metadata = 'None',
                              keep_significant = F,
                              displayed_plot = 'main',
                              p_val_threshold = 0.05,
                              fc_threshold = 2,
                              marker_size = 6,
                              opacity = 1,
                              color_palette = 'Spectral',
                              selected_function = "mean",
                              selected_test = "t-Test",
                              img_format = "png")

      self$param_heatmap(auto_refresh = T,
                         dataset = 'Z-scored total normalized table',
                         impute = T,
                         cluster_samples = T,
                         cluster_features = T,
                         map_sample_data = NULL,
                         map_feature_data = NULL,
                         map_feature_terms = NULL,
                         multival_cols = "None",
                         group_column_da = self$indices$group_col,
                         apply_da = T,
                         alpha_da = 0.8,
                         color_palette = 'RdYlBu',
                         reverse_palette = F,
                         img_format = "png")


      self$param_samples_correlation(auto_refresh = T,
                                     dataset = 'Z-scored total normalized table',
                                     correlation_method = "pearson",
                                     use = 'pairwise.complete.obs',
                                     cluster_cols = T,
                                     cluster_rows = T,
                                     row_annotations = 'Group_type',
                                     col_annotations = 'Group_type',
                                     color_palette = 'RdYlBu',
                                     reverse_palette = F,
                                     img_format = "png"
      )

      self$param_feature_correlation(
        auto_refresh = T,
        dataset = 'Z-scored total normalized table',
        multival_cols = 'None',
        map_feature_terms = NULL,
        correlation_method = "pearson",
        use = 'pairwise.complete.obs',
        cluster_cols = T,
        cluster_rows = T,
        row_annotations = NULL,
        col_annotations = NULL,
        roh_threshold = 0.95,
        top_features = 300,
        color_palette = 'RdYlBu',
        reverse_palette = F,
        img_format = "png"
      )

      self$param_db_plot(dataset = "Total normalized table",
                         adjustment = "Benjamini-Hochberg",
                         group_column = self$indices$group_col,
                         selected_groups = unique(self$tables$raw_meta[,self$indices$group_col])[c(1,2)],
                         selected_lipid_class = NULL,
                         selected_carbon_chain = 'Carbon count (chain 1)',
                         selected_unsat = 'Double bonds (chain 1)',
                         selected_function = "median",
                         selected_test = "t-Test",
                         fc_range = c(-5, 5),
                         fc_values = c(-1, 1),
                         pval_range = c(0, 5),
                         pval_values = c(1, 5),
                         img_format = "png")

      self$param_gsea(data_table = 'Raw data table',
                      meta_table = 'Raw metadata table',
                      group_col = self$indices$group_col,
                      groups = unique(self$tables$raw_meta[,self$indices$group_col])[c(1,2)],
                      used_function = "median",
                      test = "t-Test",
                      p_value_cutoff_prep = 0.05,
                      prot_list = 'GSEA prot list',
                      ont = 'Gene ontology (ALL)',
                      minGSSize = 3,
                      maxGSSize = 800,
                      p_value_cutoff = 0.05,
                      verbose = TRUE,
                      OrgDb = "org.Hs.eg.db",
                      pAdjustMethod = 'BH',
                      termsim_method = 'JC',
                      termsim_showcat = 200)

      self$param_overrepresentation(pval_cutoff_features = 0.05,
                                    padjust_features = 'Benjamini-Hochberg',
                                    pval_cutoff = 0.05,
                                    pAdjustMethod = "BH",
                                    fc_threshold = 2,
                                    ont = "Gene ontology (ALL)",
                                    qval_cutoff = 0.05,
                                    minGSSize = 10,
                                    maxGSSize = 500)

      self$param_dot_plot(showCategory = 10,
                          mode = "Both",
                          img_format = "png")

      self$param_ridge_plot(showCategory = 30,
                            img_format = "png")

    },

    #--------------------------------------------------- Plot table methods ----

    # Volcano table
    get_volcano_table = function(data_table = self$tables$raw_data,
                                 volcano_table = self$tables$feature_table,
                                 group_col = self$params$volcano_plot$group_col,
                                 used_function = self$params$volcano_plot$selected_function,
                                 test = self$params$volcano_plot$selected_test,
                                 group_1 = self$params$volcano_plot$group_1,
                                 group_2 = self$params$volcano_plot$group_2) {

      rownames_group_1 = rownames(self$tables$raw_meta)[self$tables$raw_meta[, group_col] == group_1]
      rownames_group_2 = rownames(self$tables$raw_meta)[self$tables$raw_meta[, group_col] == group_2]
      all_rownames = sort(unique(c(rownames_group_1, rownames_group_2)))

      # Filter data to keep only the two groups
      data_table = data_table[all_rownames,]

      # Get the indices for each group
      idx_group_1 = which(rownames(data_table) %in% rownames_group_1)
      idx_group_2 = which(rownames(data_table) %in% rownames_group_2)
      
      # Remove empty columns
      dead_features = colnames(data_table)
      data_table = remove_empty_cols(table = data_table)
      dead_features = setdiff(dead_features, colnames(data_table))

      if (length(dead_features) > 0) {
        dead_features = which(rownames(volcano_table) %in% dead_features)
        volcano_table = volcano_table[-dead_features,]
      }

      # Collect fold change and p-values
      volcano_table$fold_change = get_fold_changes(data_table = data_table,
                                                   idx_group_1 = idx_group_1,
                                                   idx_group_2 = idx_group_2,
                                                   used_function = used_function,
                                                   impute_inf = F)


      volcano_table$p_val = get_p_val(data_table = data_table,
                                      idx_group_1 = idx_group_1,
                                      idx_group_2 = idx_group_2,
                                      used_function = test,
                                      impute_na = F)
      volcano_table$q_val_bh = stats::p.adjust(volcano_table$p_val, method = "BH")

      volcano_table$minus_log10_p_value = -log10(volcano_table$p_val)
      volcano_table$log2_fold_change = log2(volcano_table$fold_change)
      volcano_table$minus_log10_p_value_bh_adj = -log10(volcano_table$q_val_bh)

      self$tables$volcano_table = volcano_table
    },

    # Double bond plot table
    get_dbplot_table_single = function(data_table = self$tables[[self$params$db_plot$dataset]],
                                       dbplot_table = self$tables$feature_table,
                                       col_group = self$params$db_plot$group_column,
                                       used_function = self$params$db_plot$selected_function,
                                       group_1 = self$params$db_plot$selected_groups[1]){

      # Set the averaging function
      if (used_function == "median") {
        av_function = function(x) {return(median(x, na.rm = T))}
      } else {
        av_function = function(x) {return(mean(x, na.rm = T))}
      }

      # Get the rownames for each group
      idx_group_1 = rownames(self$tables$raw_meta)[self$tables$raw_meta[, col_group] == group_1]

      # Remove empty columns
      dead_features = colnames(data_table)
      data_table = remove_empty_cols(table = data_table)
      dead_features = setdiff(dead_features, colnames(data_table))

      if (length(dead_features) > 0) {
        dead_features = which(rownames(dbplot_table) %in% dead_features)
        dbplot_table = dbplot_table[-dead_features,]
      }


      averages = apply(data_table,2,av_function)
      dbplot_table[, "averages"] = averages

      lips = rownames(dbplot_table)
      txt_medians = as.character(round(dbplot_table[,"averages"],5))
      dbplot_table$text = paste0(lips, " | ", used_function, ": ", txt_medians)

      self$tables$dbplot_table = dbplot_table
    },

    get_dbplot_table_double = function(data_table,
                                       dbplot_table = self$tables$feature_table,
                                       col_group = self$params$db_plot$group_column,
                                       used_function = self$params$db_plot$selected_function,
                                       test = self$params$db_plot$selected_test,
                                       group_1 = self$params$db_plot$selected_groups[1],
                                       group_2 = self$params$db_plot$selected_groups[2]) {


      rownames_group_1 = rownames(self$tables$raw_meta)[self$tables$raw_meta[, col_group] == group_1]
      rownames_group_2 = rownames(self$tables$raw_meta)[self$tables$raw_meta[, col_group] == group_2]
      all_rownames = sort(unique(c(rownames_group_1, rownames_group_2)))

      # Filter data to keep only the two groups
      data_table = data_table[all_rownames,]

      # Get the indices for each group
      idx_group_1 = which(rownames(data_table) %in% rownames_group_1)
      idx_group_2 = which(rownames(data_table) %in% rownames_group_2)

      # Get all row names from both groups
      idx_all = c(idx_group_1, idx_group_2)
      idx_all = sort(unique(idx_all))

      # Filter data to keep only the two groups
      data_table = data_table[idx_all,]

      # Remove empty columns
      dead_features = colnames(data_table)
      data_table = remove_empty_cols(table = data_table)
      dead_features = setdiff(dead_features, colnames(data_table))

      if (length(dead_features) > 0) {
        dead_features = which(rownames(dbplot_table) %in% dead_features)
        dbplot_table = dbplot_table[-dead_features,]
      }


      # Collect fold change and p-values
      dbplot_table$fold_change = get_fold_changes(data_table = data_table,
                                                  idx_group_1 = idx_group_1,
                                                  idx_group_2 = idx_group_2,
                                                  used_function = used_function)


      dbplot_table$p_val = get_p_val(data_table = data_table,
                                     idx_group_1 = idx_group_1,
                                     idx_group_2 = idx_group_2,
                                     used_function = test)
      dbplot_table$q_val_bh = stats::p.adjust(dbplot_table$p_val, method = "BH")

      dbplot_table$minus_log10_p_value = -log10(dbplot_table$p_val)
      dbplot_table$log2_fold_change = log2(dbplot_table$fold_change)
      dbplot_table$minus_log10_p_value_bh_adj = -log10(dbplot_table$q_val_bh)

      lips = rownames(dbplot_table)
      fc = as.character(round(dbplot_table[,"log2_fold_change"],2))
      pval = as.character(round(dbplot_table[,"minus_log10_p_value_bh_adj"],2))
      dbplot_table$text = paste0(lips, " | log2(fc): ", fc, " | -log10(bh(pval)): ", pval)



      self$tables$dbplot_table = dbplot_table
    },

    #---------------------------------------------------- GSEA & OR methods ----

    # GSEA table
    get_prot_list = function(data_table = self$table_switch_local(self$params$gsea$data_table),
                             meta_table = self$table_switch_local(self$params$gsea$meta_table),
                             group_col = self$params$gsea$group_col,
                             group_1 = self$params$gsea$groups[1],
                             group_2 = self$params$gsea$groups[2],
                             used_function = self$params$gsea$used_function,
                             test = self$params$gsea$test,
                             context = 'gsea'
    ) {

      rownames_group_1 = rownames(meta_table)[meta_table[, group_col] == group_1]
      rownames_group_2 = rownames(meta_table)[meta_table[, group_col] == group_2]
      all_rownames = sort(unique(c(rownames_group_1, rownames_group_2)))

      # Filter data to keep only the two groups
      data_table = data_table[all_rownames,]

      # Get the indices for each group
      idx_group_1 = which(rownames(data_table) %in% rownames_group_1)
      idx_group_2 = which(rownames(data_table) %in% rownames_group_2)


      # Remove empty columns
      data_table = remove_empty_cols(table = data_table)


      prot_list = data.frame(row.names = colnames(data_table))


      # Collect fold changes
      prot_list$fold_change = get_fold_changes(data_table = data_table,
                                               idx_group_1 = idx_group_1,
                                               idx_group_2 = idx_group_2,
                                               used_function = used_function)


      prot_list$log2_fold_change = log2(prot_list$fold_change)

      # Collect p-values
      prot_list$p_val = get_p_val(data_table = data_table,
                                  idx_group_1 = idx_group_1,
                                  idx_group_2 = idx_group_2,
                                  used_function = test)

      prot_list$minus_log10_p_value = -log10(prot_list$p_val)
      prot_list$p_val_bh = stats::p.adjust(prot_list$p_val, method = "BH")
      prot_list$minus_log10_p_value_bh_adj = -log10(prot_list$p_val_bh)

      if (context == 'gsea') {
        self$tables$gsea_prot_list = prot_list
      } else if (context == 'ora') {
        self$tables$ora_prot_list = prot_list
      }
    },

    # GSEA object
    get_gsea_object = function(prot_list = self$table_switch_local(self$params$gsea$prot_list),
                               custom_col = NULL,
                               feature_table = self$tables$feature_table,
                               keyType = self$indices$feature_id_type,
                               ont = self$params$gsea$ont,
                               minGSSize = self$params$gsea$minGSSize,
                               maxGSSize = self$params$gsea$maxGSSize,
                               p_value_cutoff = self$params$gsea$p_value_cutoff,
                               verbose = self$params$gsea$verbose,
                               OrgDb = self$params$gsea$OrgDb,
                               pAdjustMethod = self$params$gsea$pAdjustMethod,
                               termsim_method = self$params$gsea$termsim_method,
                               termsim_showcat = self$params$gsea$termsim_showcat) {

      # Checks
      if (is.null(ont) & is.null(custom_col)) {
        print('No ontology nor custom col provided: returning Null')
        return()
      }

      prot_names = rownames(prot_list)
      prot_list = prot_list$log2_fold_change
      names(prot_list) = prot_names

      # NA omit and sort
      prot_list = na.omit(prot_list)
      prot_list = sort(prot_list, decreasing = TRUE)

      if (!is.null(custom_col)) {
        term2gene = get_term2gene(feature_table = feature_table,
                                  column = custom_col,
                                  sep = "\\|")
        gsea = custom_gsea(geneList = prot_list,
                           minGSSize = minGSSize,
                           maxGSSize = maxGSSize,
                           pvalueCutoff = p_value_cutoff,
                           verbose = verbose,
                           pAdjustMethod = pAdjustMethod,
                           term2gene = term2gene)
      } else {
        gsea = clusterProfiler::gseGO(geneList=prot_list,
                                      ont = ont,
                                      keyType = keyType,
                                      minGSSize = minGSSize,
                                      maxGSSize = maxGSSize,
                                      pvalueCutoff = p_value_cutoff,
                                      verbose = verbose,
                                      OrgDb = OrgDb,
                                      pAdjustMethod = pAdjustMethod)
      }



      if (nrow(gsea@result) > 0) {
        gsea = enrichplot::pairwise_termsim(gsea, method = termsim_method, semData = NULL, showCategory = termsim_showcat)
      }
      self$tables$gsea_object = gsea

    },

    over_representation_analysis = function(prot_list = self$tables$ora_prot_list,
                                            custom_col = NULL,
                                            feature_table = self$tables$feature_table,
                                            pval_cutoff_features = self$params$overrepresentation$pval_cutoff_features,
                                            padjust_features = self$params$overrepresentation$padjust_features,
                                            pval_cutoff = self$params$overrepresentation$pval_cutoff,
                                            pAdjustMethod = self$params$overrepresentation$pAdjustMethod,
                                            fc_threshold = self$params$overrepresentation$fc_threshold,
                                            keyType = self$indices$feature_id_type,
                                            ont = self$params$overrepresentation$ont,
                                            qval_cutoff = self$params$overrepresentation$qval_cutoff,
                                            minGSSize = self$params$overrepresentation$minGSSize,
                                            maxGSSize  = self$params$overrepresentation$maxGSSize) {
      # Checks
      if (is.null(ont) & is.null(custom_col)) {
        print('No ontology nor custom col provided: returning Null')
        return()
      }

      # Get universe (all features)
      universe = prot_list$log2_fold_change
      names(universe) = rownames(prot_list)
      universe = na.omit(universe)
      universe = sort(universe, decreasing = TRUE)
      universe = names(universe)

      # Get significant features
      if (padjust_features == "Benjamini-Hochberg") {
        features = prot_list[prot_list$p_val_bh <= pval_cutoff_features,]
      } else {
        features = prot_list[prot_list$p_val <= pval_cutoff_features,]
      }
      features = features[abs(features$log2_fold_change) >= log2(fc_threshold),]

      if (nrow(features) == 0) {
        return()
      }

      # Sort feature table
      features = features[order(-features$log2_fold_change),]

      if (!is.null(custom_col)) {
        term2gene = get_term2gene(feature_table = feature_table,
                                  column = custom_col,
                                  sep = "\\|")
        go_enrich = custom_ora(geneList = rownames(features),
                               pvalueCutoff = pval_cutoff,
                               pAdjustMethod = pAdjustMethod,
                               qvalueCutoff = qval_cutoff,
                               minGSSize = minGSSize,
                               maxGSSize = maxGSSize,
                               term2gene = term2gene)
      } else {
        go_enrich = clusterProfiler::enrichGO(gene = rownames(features),
                                              universe = universe,
                                              OrgDb = 'org.Hs.eg.db',
                                              keyType = keyType,
                                              readable = T,
                                              ont = ont,
                                              pvalueCutoff = pval_cutoff,
                                              pAdjustMethod = pAdjustMethod,
                                              qvalueCutoff = qval_cutoff,
                                              minGSSize = minGSSize,
                                              maxGSSize  = maxGSSize)
      }

      self$tables$go_enrich = go_enrich
    },

    #----------------------------------------------------- Plotting methods ----
    # Class distribution
    plot_class_distribution = function(table = self$params$class_distribution$dataset,
                                       meta_table = self$tables$raw_meta,
                                       group_col = self$params$class_distribution$group_col,
                                       color_palette = self$params$class_distribution$color_palette,
                                       width = NULL,
                                       height = NULL){

      table = self$table_check_convert(table)

      # Produce the class x group table
      samp_list = rownames(table)
      class_list = colnames(table)
      group_list = sort(unique(meta_table[,group_col]))
      
      plot_table = data.frame(matrix(data = 0.0,
                                     nrow = length(class_list),
                                     ncol = length(group_list)))
      rownames(plot_table) = class_list
      colnames(plot_table) = group_list
      
      for (c in class_list) {
        for (g in group_list){
          s = rownames(meta_table)[meta_table[,group_col] %in% g]
          m = mean(as.matrix(table[s, c]))
          plot_table[c,g] = m
        }
      }

      # Store the plot_table
      self$tables$class_distribution_table = plot_table

      colors = brewer.pal(as.numeric(colors_switch(color_palette)), color_palette)
      colors = colorRampPalette(colors)(length(group_list))
      colors = setNames(colors, group_list)

      # Produce the plot
      i = 1
      fig = plotly::plot_ly(colors = unname(colors), width = width, height = height)
      for (col in colnames(plot_table)) {
        fig = fig %>% add_trace(x = rownames(plot_table), y = plot_table[,col],
                                name = col, color = colors[col], type  = "bar")
        fig = fig %>% layout(legend = list(orientation = 'h', xanchor = "center", x = 0.5),
                             yaxis = list(title = "Concentration"))
        i = i + 1
      }

      self$plots$class_distribution = fig
    },

    # Class comparison
    plot_class_comparison = function(data_table = self$params$class_comparison$dataset,
                                     meta_table = self$tables$raw_meta,
                                     group_col = self$params$class_comparison$group_col,
                                     color_palette = self$params$class_comparison$color_palette,
                                     width = NULL,
                                     height = NULL){

      data_table = self$table_check_convert(data_table)

      # Get sample groups and the list of classes
      groups = sort(unique(meta_table[,group_col]))
      class_list = colnames(data_table)

      x_dim = ceiling(sqrt(length(class_list)))
      y_dim = floor(sqrt(length(class_list)))


      x_step = 1/x_dim
      y_step = 1/y_dim

      x = x_step/2
      y = 0.97 - y_step
      i = 1

      annotations = c()
      for (c in class_list) {
        tmp_ann = list(
          x = x,
          y = y,
          text = c,
          xref = "paper",
          yref = "paper",
          xanchor = "center",
          yanchor = "bottom",
          showarrow = FALSE)
        annotations[[i]] = tmp_ann
        i = i + 1
        x = x + x_step
        if (x >= 1) {
          x = x_step/2
          y = y - y_step}
      }
      annotations[[i]] = list(x = -0.08, y = 0.5, text = "Concentration",
                              font = list(size = 10),
                              textangle = 270, showarrow = FALSE, xref='paper',
                              yref='paper')

      colors = brewer.pal(as.numeric(colors_switch(color_palette)), color_palette)
      colors = colorRampPalette(colors)(length(groups))
      colors = setNames(colors, groups)

      # Plot list will be the list of subplots
      plot_list = c()

      # Cleared groups is created for the legends
      cleared_groups = c()
      j = 1
      for (c in class_list) {
        i = 1
        subplot = plot_ly(colors = unname(colors), width = width, height = height)
        for (g in groups){
          if (g %in% cleared_groups) {
            first_bool = FALSE
          }else{
            first_bool = TRUE
            cleared_groups = c(cleared_groups, g)
          }

          # For each class, each group
          s = rownames(meta_table)[meta_table[, group_col] %in% g] # Get the samples for the current group
          d = data_table[s, c] # Get the concentrations for all s samples in the current class c
          m = mean(d) # Get the mean concentration for samples s for class c

          # Subplot for the bar chart displaying the mean concentration
          subplot = subplot %>% add_trace(x = g, y = m, type  = "bar", name = g,
                                          color = colors[g], alpha = 1,
                                          legendgroup=i, showlegend = first_bool)

          # Subplot for boxplots displaying the median and all datapoints
          subplot = subplot %>% add_trace(x = g, y = d, type  = "box", boxpoints = "all",
                                          pointpos = 0, name = g, color = colors[g],
                                          line = list(color = 'rgb(100,100,100)'),
                                          marker = list(color = 'rgb(100,100,100)'), alpha = 1,
                                          legendgroup=i, showlegend = FALSE,
                                          text = s,
                                          hoverinfo = "text")
          subplot = subplot %>% layout(xaxis= list(showticklabels = FALSE),
                                       yaxis = list(tickfont = list(size = 8)))
          i = i + 1
        }
        plot_list[[j]] = plotly_build(subplot)
        j = j + 1
      }

      fig = subplot(plot_list, nrows = y_dim, margin = 0.035, titleX = TRUE)
      fig = fig %>% layout(legend = list(orientation = 'h', xanchor = "center", x = 0.5),
                           annotations = annotations)

      self$plots$class_comparison = fig
    },

    ## Volcano plot
    plot_volcano = function(data_table = self$tables$volcano_table,
                            adjustment = self$params$volcano_plot$adjustment,
                            group_1 = self$params$volcano_plot$group_1,
                            group_2 = self$params$volcano_plot$group_2,
                            feature_metadata = self$params$volcano_plot$feature_metadata,
                            keep_significant = self$params$volcano_plot$keep_significant,
                            displayed_plot = self$params$volcano_plot$displayed_plot,
                            p_val_threshold = self$params$volcano_plot$p_val_threshold,
                            fc_threshold = self$params$volcano_plot$fc_threshold,
                            marker_size = self$params$volcano_plot$marker_size,
                            opacity = self$params$volcano_plot$opacity,
                            color_palette = self$params$volcano_plot$color_palette,
                            width = NULL,
                            height = NULL){

      data_table = self$table_check_convert(data_table)

      p_val_threshold = as.numeric(p_val_threshold)
      fc_threshold = as.numeric(fc_threshold)
      marker_size = as.numeric(marker_size)
      opacity = as.numeric(opacity)

      if (adjustment == 'BH') {
        if (keep_significant) {
          data_table = data_table[data_table$q_val_bh <= p_val_threshold,]
          data_table = data_table[(data_table$log2_fold_change >= log2(fc_threshold)) | (data_table$log2_fold_change <= -log2(fc_threshold)),]
        }
        p_vals = data_table$q_val_bh
        y_label = '-Log10(BH(p-value))'
      } else {
        if (keep_significant) {
          data_table = data_table[data_table$p_val <= p_val_threshold,]
          data_table = data_table[(data_table$log2_fold_change >= log2(fc_threshold)) | (data_table$log2_fold_change <= -log2(fc_threshold)),]
        }
        p_vals = data_table$p_val
        y_label = '-Log10(p-value)'
      }

      if (!is.null(feature_metadata)) {
        if (feature_metadata %in% colnames(data_table)) {
          feature_metadata = data_table[,feature_metadata]
        } else {
          feature_metadata = NULL
        }
      }

      displayed_text = paste0(paste0(rownames(data_table), '\n'),
                              paste0('p-value: ', round(p_vals, 3), '\n'),
                              paste0('FC: ', round(data_table$fold_change, 2)))

      fig = volcano_main(fc_vals = data_table$fold_change,
                         p_vals = p_vals,
                         names = displayed_text,
                         y_label = y_label,
                         left_label = group_1,
                         right_label = group_2,
                         groups = feature_metadata,
                         displayed_plot = displayed_plot,
                         color_palette = color_palette,
                         p_val_threshold = p_val_threshold,
                         fc_threshold = fc_threshold,
                         marker_size = marker_size,
                         opacity = opacity)


      self$plots$volcano_plot = fig
    },

    ## Heatmap plot
    plot_heatmap = function(data_table = self$params$heatmap$dataset,
                            impute = self$params$heatmap$impute,
                            meta_table = self$tables$raw_meta,
                            meta_table_features = self$tables$feature_table,
                            cluster_rows = self$params$heatmap$cluster_samples,
                            cluster_cols = self$params$heatmap$cluster_features,
                            row_annotations = self$params$heatmap$map_sample_data,
                            col_annotations = self$params$heatmap$map_feature_data,
                            map_feature_terms = self$params$heatmap$map_feature_terms,
                            apply_da = self$params$heatmap$apply_da,
                            group_column_da = self$params$heatmap$group_column_da,
                            alpha_da = self$params$heatmap$alpha_da,
                            color_palette = self$params$heatmap$color_palette,
                            reverse_palette = self$params$heatmap$reverse_palette,
                            width = NULL,
                            height = NULL) {

      data_table = self$table_check_convert(data_table)

      if (apply_da) {
        data_table = apply_discriminant_analysis(data_table = data_table,
                                                 group_list = meta_table[,group_column_da],
                                                 nlambda = 100,
                                                 alpha = alpha_da)

        meta_table_features = meta_table_features[colnames(data_table),]
      }


      # Save table as heatmap table
      self$tables$heatmap_table = data_table

      # Set the clustering
      if (cluster_rows & cluster_cols) {
        dendrogram_list = "both"
      } else if (cluster_rows) {
        dendrogram_list = "column" # Because of the transpose, rows => cols
      } else if (cluster_cols) {
        dendrogram_list = "row" # Because of the transpose, cols => rows
      } else {
        dendrogram_list = "none"
      }

      # Set zmax and zmin
      val_list = as.vector(data_table)
      val_list = na.omit(val_list)
      val_list = sort(val_list)

      zmax = min(c(abs(min(val_list)), max(val_list)))
      zmin = -zmax

      # Filter out the data
      data_table[data_table > zmax] = zmax
      data_table[data_table < zmin] = zmin

      # Annotations
      if (!is.null(row_annotations)) {
        if (length(row_annotations) > 1) {
          row_annotations = meta_table[, row_annotations]
          colnames(row_annotations) = stringr::str_replace_all(colnames(row_annotations), "_", " ")
        } else {
          row_names = row_annotations
          row_annotations = as.data.frame(meta_table[, row_annotations],
                                          row.names = rownames(meta_table))
          colnames(row_annotations) = stringr::str_replace_all(row_names, "_", " ")
        }
      }

      # Reorder the feature metadata according to the data_table order
      meta_table_features = meta_table_features[c(colnames(data_table)),]

      if (!is.null(col_annotations)) {
        clean_names = sub("^(.)", "\\U\\1", tolower(str_replace_all(col_annotations, '_', ' ')), perl = TRUE)
        if (length(col_annotations) == 1) {
          col_annotations = as.data.frame(meta_table_features[, col_annotations],
                                          row.names = rownames(meta_table_features))
          colnames(col_annotations) = clean_names
        } else {
          col_annotations = meta_table_features[, col_annotations]
          colnames(col_annotations) = clean_names
        }
      }

      # Add multivalue annotations
      if (!is.null(map_feature_terms)) {
        if (is.null(col_annotations)) {
          col_annotations = as.data.frame(meta_table_features[, NULL])
        }
        for (name in names(map_feature_terms))
          col_annotations[[name]] = map_feature_terms[[name]][rownames(col_annotations)]
      }


      # Impute missing values
      if (impute) {
        data_table[is.na(data_table)] = zmin
      }

      # Get the color palette
      color_count = colors_switch(color_palette)
      color_palette = RColorBrewer::brewer.pal(color_count, color_palette)
      color_palette = c(color_palette[1], color_palette[round(color_count/2)] , color_palette[color_count])
      if (reverse_palette) {
        color_palette = base::rev(color_palette)
      }

      # Plot the data
      self$plots$heatmap = heatmaply::heatmaply(x = t(data_table),
                                                scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
                                                  low = color_palette[3],
                                                  mid = color_palette[2],
                                                  high = color_palette[1],
                                                  midpoint = 0,
                                                  limits = c(zmin, zmax)
                                                ),
                                                width = width,
                                                height = height,
                                                limits = c(zmin, zmax),
                                                col_side_colors = row_annotations,
                                                row_side_colors = col_annotations,
                                                dendrogram = dendrogram_list)

    },

    ## Sample correlation plot
    plot_samples_correlation = function(data_table = self$params$samples_correlation$dataset,
                                        meta_table = self$tables$raw_meta,
                                        correlation_method = self$params$samples_correlation$correlation_method,
                                        use = self$params$samples_correlation$use,
                                        cluster_cols = self$params$samples_correlation$cluster_cols,
                                        cluster_rows = self$params$samples_correlation$cluster_rows,
                                        row_annotations = self$params$samples_correlation$row_annotations,
                                        col_annotations = self$params$samples_correlation$col_annotations,
                                        color_palette = self$params$samples_correlation$color_palette,
                                        reverse_palette = self$params$samples_correlation$reverse_palette,
                                        width = NULL,
                                        height = NULL) {

      data_table = self$table_check_convert(data_table)

      # Set the clustering
      if (cluster_rows & cluster_cols) {
        dendrogram_list = "both"
      } else if (cluster_rows) {
        dendrogram_list = "column" # Because of the transpose, rows => cols
      } else if (cluster_cols) {
        dendrogram_list = "row" # Because of the transpose, cols => rows
      } else {
        dendrogram_list = "none"
      }

      data_table = stats::cor(x = t(data_table),
                              y = NULL,
                              use = use,
                              method = correlation_method)

      # diag(data_table) = 0

      # Set zmax and zmin
      val_list = as.vector(data_table)
      val_list = na.omit(val_list)
      val_list = sort(val_list)

      zmax = min(c(abs(min(val_list)), max(val_list)))
      zmin = -zmax

      # Filter out the data
      data_table[data_table > zmax] = zmax
      data_table[data_table < zmin] = zmin

      # Annotations
      if (!is.null(row_annotations)) {
        if (length(row_annotations) > 1) {
          row_annotations = meta_table[, row_annotations]
          colnames(row_annotations) = stringr::str_replace_all(colnames(row_annotations), "_", " ")
        } else {
          row_names = row_annotations
          row_annotations = as.data.frame(meta_table[, row_annotations],
                                          row.names = rownames(meta_table))
          colnames(row_annotations) = stringr::str_replace_all(row_names, "_", " ")
        }
      }

      if (!is.null(col_annotations)) {
        if (length(col_annotations) > 1) {
          col_annotations = meta_table[, col_annotations]
          colnames(col_annotations) = stringr::str_replace_all(colnames(col_annotations), "_", " ")
        } else {
          row_names = col_annotations
          col_annotations = as.data.frame(meta_table[, col_annotations],
                                          row.names = rownames(meta_table))
          colnames(col_annotations) = stringr::str_replace_all(row_names, "_", " ")
        }
      }

      # Save table as heatmap table
      self$tables$samples_correlation = data_table

      # Get the color palette
      color_count = colors_switch(color_palette)
      color_palette = RColorBrewer::brewer.pal(color_count, color_palette)
      color_palette = c(color_palette[1], color_palette[round(color_count/2)] , color_palette[color_count])
      if (reverse_palette) {
        color_palette = base::rev(color_palette)
      }

      # Plot the data
      self$plots$samples_correlation = heatmaply::heatmaply(x = t(data_table),
                                                            scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
                                                              low = color_palette[3],
                                                              mid = color_palette[2],
                                                              high = color_palette[1],
                                                              midpoint = 0,
                                                              limits = c(zmin, zmax)
                                                            ),
                                                            width = width,
                                                            height = height,
                                                            limits = c(zmin, zmax),
                                                            col_side_colors = row_annotations,
                                                            row_side_colors = col_annotations,
                                                            dendrogram = dendrogram_list)

    },

    ## Feature correlation plot
    plot_feature_correlation = function(data_table = self$params$feature_correlation$dataset,
                                        meta_table = self$tables$feature_table,
                                        map_feature_terms = self$params$feature_correlation$map_feature_terms,
                                        correlation_method = self$params$feature_correlation$correlation_method,
                                        use = self$params$feature_correlation$use,
                                        cluster_cols = self$params$feature_correlation$cluster_cols,
                                        cluster_rows = self$params$feature_correlation$cluster_rows,
                                        row_annotations = self$params$feature_correlation$row_annotations,
                                        col_annotations = self$params$feature_correlation$col_annotations,
                                        roh_threshold = self$params$feature_correlation$roh_threshold,
                                        top_features = self$params$feature_correlation$top_features,
                                        color_palette = self$params$feature_correlation$color_palette,
                                        reverse_palette = self$params$feature_correlation$reverse_palette,
                                        width = NULL,
                                        height = NULL) {

      data_table = self$table_check_convert(data_table)

      # Set the clustering
      if (cluster_rows & cluster_cols) {
        dendrogram_list = "both"
      } else if (cluster_rows) {
        dendrogram_list = "column" # Because of the transpose, rows => cols
      } else if (cluster_cols) {
        dendrogram_list = "row" # Because of the transpose, cols => rows
      } else {
        dendrogram_list = "none"
      }

      data_table = stats::cor(x = data_table,
                              y = NULL,
                              use = use,
                              method = correlation_method)

      diag(data_table) = 0
      max_abs_values = apply(data_table, 1, function(x) max(abs(x), na.rm = T))
      roh_filter = unname(which(max_abs_values >= roh_threshold))
      diag(data_table) = 1

      if (length(roh_filter) > top_features) {
        best_hits = names(sort(rowSums(abs(data_table), na.rm = T), decreasing = T)[1:top_features])
        roh_filter = which((rownames(data_table) %in% best_hits))
      }
      data_table = data_table[roh_filter, roh_filter]
      meta_table = meta_table[rownames(data_table),]

      # Set zmax and zmin
      val_list = as.vector(data_table)
      val_list = na.omit(val_list)
      val_list = sort(val_list)

      zmax = min(c(abs(min(val_list)), max(val_list)))
      zmin = -zmax

      # Filter out the data
      data_table[data_table > zmax] = zmax
      data_table[data_table < zmin] = zmin

      # Annotations
      if (!is.null(row_annotations)) {
        if (length(row_annotations) > 1) {
          row_annotations = meta_table[, row_annotations]
          colnames(row_annotations) = stringr::str_replace_all(colnames(row_annotations), "_", " ")
        } else {
          row_names = row_annotations
          row_annotations = as.data.frame(meta_table[, row_annotations],
                                          row.names = rownames(meta_table))
          colnames(row_annotations) = stringr::str_replace_all(row_names, "_", " ")
        }
      }

      if (!is.null(col_annotations)) {
        if (length(col_annotations) > 1) {
          col_annotations = meta_table[, col_annotations]
          colnames(col_annotations) = stringr::str_replace_all(colnames(col_annotations), "_", " ")
        } else {
          row_names = col_annotations
          col_annotations = as.data.frame(meta_table[, col_annotations],
                                          row.names = rownames(meta_table))
          colnames(col_annotations) = stringr::str_replace_all(row_names, "_", " ")
        }
      }

      # Add multivalue annotations
      if (!is.null(map_feature_terms)) {
        if (is.null(col_annotations)) {
          col_annotations = as.data.frame(meta_table[, NULL])
        }
        for (name in names(map_feature_terms))
          col_annotations[[name]] = map_feature_terms[[name]][rownames(col_annotations)]
      }

      # Save table as heatmap table
      self$tables$feature_correlation = data_table

      # Get the color palette
      color_count = colors_switch(color_palette)
      color_palette = RColorBrewer::brewer.pal(color_count, color_palette)
      color_palette = c(color_palette[1], color_palette[round(color_count/2)] , color_palette[color_count])
      if (reverse_palette) {
        color_palette = base::rev(color_palette)
      }

      # Plot the data
      self$plots$feature_correlation = heatmaply::heatmaply(x = data_table,
                                                            scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
                                                              low = color_palette[3],
                                                              mid = color_palette[2],
                                                              high = color_palette[1],
                                                              midpoint = 0,
                                                              limits = c(zmin, zmax)
                                                            ),
                                                            width = width,
                                                            height = height,
                                                            limits = c(zmin, zmax),
                                                            col_side_colors = row_annotations,
                                                            row_side_colors = col_annotations,
                                                            dendrogram = dendrogram_list)

    },

    ## PCA scores and loading plots
    plot_pca = function(data_table = self$params$pca$data_table,
                        meta_table = self$tables$raw_meta,
                        feature_table = self$tables$feature_table,
                        sample_groups_col = self$params$pca$sample_groups_col,
                        feature_groups_col = self$params$pca$feature_groups_col,
                        apply_da = self$params$pca$apply_da,
                        alpha_da = self$params$pca$alpha_da,
                        pca_method = self$params$pca$pca_method,
                        nPcs = self$params$pca$nPcs,
                        displayed_pc_1 = self$params$pca$displayed_pc_1,
                        displayed_pc_2 = self$params$pca$displayed_pc_2,
                        completeObs = self$params$pca$completeObs,
                        displayed_plots = self$params$pca$displayed_plots,
                        colors_palette = self$params$pca$colors_palette,
                        return_data = TRUE,
                        width = NULL,
                        height = NULL) {

      data_table = self$table_check_convert(data_table)

      alpha_da = as.numeric(alpha_da)
      nPcs= as.numeric(nPcs)
      displayed_pc_1 = as.numeric(displayed_pc_1)
      displayed_pc_2 = as.numeric(displayed_pc_2)

      if (is.character(data_table)) {
        data_table = self$tables[[data_table]]
      }

      sample_groups = meta_table[rownames(data_table),sample_groups_col]
      if (apply_da) {
        data_table = apply_discriminant_analysis(data_table = data_table,
                                                 group_list = sample_groups,
                                                 nlambda = 100,
                                                 alpha = alpha_da)}

      ncol_1 = ncol(data_table)
      data_table = data_table[,!is.na(colSums(data_table, na.rm = T))]
      ncol_2 = ncol(data_table)
      if(ncol_2 != ncol_1) {
        print_time(paste0("PCA : dropped ", ncol_1 - ncol_2, " features with no signal variation."))
      }

      if (!is.null(feature_groups_col) & !is.null(feature_table)) {
        if (length(feature_groups_col) == 1) {
          if (feature_groups_col %in% colnames(feature_table)) {
            feature_groups = feature_table[colnames(data_table),feature_groups_col]
            if (length(which(is.na(feature_groups))) < 30) {
              feature_groups[which(is.na(feature_groups))] = colnames(data_table)[which(is.na(feature_groups))]
            } else {
              feature_groups[which(is.na(feature_groups))] = "UNK"
            }
          } else {
            feature_groups = NULL
          }
        } else {
          feature_groups = feature_groups_col[colnames(data_table)]
          print(feature_groups)
        }
      } else {
        feature_groups = NULL
      }


      pca_out = pca_main(data_table = data_table,
                         sample_groups = sample_groups,
                         feature_groups = feature_groups,
                         nPcs = nPcs,
                         displayed_pc_1 = displayed_pc_1,
                         displayed_pc_2 = displayed_pc_2,
                         pca_method = pca_method,
                         completeObs = completeObs,
                         displayed_plots = displayed_plots,
                         colors_palette = colors_palette,
                         return_data = return_data)




      self$tables$pca_scores_table = pca_out$pca_data@scores
      self$tables$pca_loadings_table = pca_out$pca_data@loadings
      self$plots$pca_plot = pca_out$fig

    },

    ## Double bond plot
    plot_doublebonds_single = function(data_table = self$params$db_plot$dataset,
                                       lipid_class = self$params$db_plot$selected_lipid_class,
                                       carbon_selection = self$params$db_plot$selected_carbon_chain,
                                       unsat_selection = self$params$db_plot$selected_unsat,
                                       group_1 = self$params$db_plot$selected_groups[1],
                                       width = NULL,
                                       height = NULL){

      data_table = self$table_check_convert(data_table)

      x_label = carbon_selection
      y_label = unsat_selection
      carbon_selection = feature_table_cols_switch(carbon_selection)
      unsat_selection = feature_table_cols_switch(unsat_selection)
      selected_rows = rownames(data_table)[data_table["lipid_class"] == lipid_class]
      data_table = data_table[selected_rows,]
      x_lims = c(min(data_table[,carbon_selection]) -1, max(data_table[,carbon_selection]) +1)
      y_lims = c(min(data_table[,unsat_selection]) -0.5, max(data_table[,unsat_selection]) +1)

      fig = plotly::plot_ly(data_table,
                            x = data_table[,carbon_selection],
                            y = data_table[,unsat_selection],
                            type = "scatter",
                            mode = "markers",
                            size = ~averages,
                            sizes = ~c(5,40),
                            marker = list(sizemode ='diameter',
                                          opacity = 0.5,
                                          sizeref=1
                            ),
                            text = data_table$text,
                            hoverinfo = "text",
                            width = width,
                            height = height)


      fig = fig %>% layout(
        title = paste0("Lipids in class ", lipid_class, " - ", group_1),
        xaxis = list(title = x_label,
                     range = x_lims
        ),
        yaxis = list(title = y_label,
                     range = y_lims
        )
      )
      self$plots$double_bond_plot = fig
    },

    plot_doublebonds_double = function(data_table = self$tables$dbplot_table,
                                       adjustment = self$params$db_plot$adjustment,
                                       carbon_selection = self$params$db_plot$selected_carbon_chain,
                                       unsat_selection = self$params$db_plot$selected_unsat,
                                       lipid_class = self$params$db_plot$selected_lipid_class,
                                       fc_limits = self$params$db_plot$fc_values,
                                       pval_limits = self$params$db_plot$pval_values,
                                       group_1 = self$params$db_plot$selected_groups[1],
                                       group_2 = self$params$db_plot$selected_groups[2],
                                       width = NULL,
                                       height = NULL){

      x_label = carbon_selection
      y_label = unsat_selection
      carbon_selection = feature_table_cols_switch(carbon_selection)
      unsat_selection = feature_table_cols_switch(unsat_selection)
      selected_rows = rownames(data_table)[data_table["lipid_class"] == lipid_class]
      data_table = data_table[selected_rows,]
      x_lims = c(min(data_table[,carbon_selection]) -1, max(data_table[,carbon_selection]) +1)
      y_lims = c(min(data_table[,unsat_selection]) -0.5, max(data_table[,unsat_selection]) +1)
      data_table = data_table[!dplyr::between(data_table[,"log2_fold_change"], fc_limits[1], fc_limits[2]),]
      data_table = data_table[dplyr::between(data_table[,adjustment], pval_limits[1], pval_limits[2]),]
      if (nrow(data_table) > 0) {
        fig = plotly::plot_ly(data_table,
                              x = data_table[,carbon_selection],
                              y = data_table[,unsat_selection],
                              type = "scatter",
                              mode = "markers",
                              size = data_table[,adjustment],
                              sizes = ~c(5,40),
                              marker = list(color = ~log2_fold_change,
                                            sizemode ='diameter',
                                            opacity = 0.5,
                                            sizeref=1,
                                            colorscale = 'RdBu',
                                            cmax = max(abs(data_table[, "log2_fold_change"])),
                                            cmin = -max(abs(data_table[, "log2_fold_change"])),
                                            colorbar=list(
                                              title='Log2(fold change)'
                                            ),
                                            line = list(width = 0)
                              ),
                              text = data_table$text,
                              hoverinfo = "text",
                              width = width,
                              height = height)
      } else {
        fig = plotly::plot_ly(data_table,
                              x = data_table[,carbon_selection],
                              y = data_table[,unsat_selection],
                              type = "scatter",
                              mode = "markers",
                              width = width,
                              height = height)
      }

      fig = fig %>% layout(
        legend= list(itemsizing='constant'),
        title = paste0("Comparison in ", lipid_class, " - ", group_1, " (blue), ", group_2, " (red)"),
        xaxis = list(title = x_label,
                     range = x_lims
        ),
        yaxis = list(title = y_label,
                     range = y_lims
        )
      )
      self$plots$double_bond_plot = fig
    },

    plot_dot_plot = function(object = self$tables$gsea_object,
                             x = "GeneRatio",
                             color = "p.adjust",
                             showCategory = self$params$dot_plot$showCategory,
                             size = NULL,
                             split = ".sign",
                             orderBy="x",
                             mode = self$params$dot_plot$mode,
                             width = NULL,
                             height = NULL){

      if (is.na(showCategory)) {
        base::warning("Invalid showCategory, setting to 10 by default")
        showCategory = 10
      }

      colorBy <- match.arg(color, c("pvalue", "p.adjust", "qvalue"))
      if (x == "geneRatio" || x == "GeneRatio") {
        x <- "GeneRatio"
        if (is.null(size))
          size <- "Count"
      } else if (x == "count" || x == "Count") {
        x <- "Count"
        if (is.null(size))
          size <- "GeneRatio"
      } else if (is(x, "formula")) {
        x <- as.character(x)[2]
        if (is.null(size))
          size <- "Count"
      } else {
        if (is.null(size))
          size  <- "Count"
      }

      if (inherits(object, c("enrichResultList", "gseaResultList"))) {
        ldf <- lapply(object, fortify, showCategory=showCategory, split=split)
        df <- dplyr::bind_rows(ldf, .id="category")
        df$category <- factor(df$category, levels=names(object))
      } else {
        df <- fortify(object, showCategory = showCategory, split=split)
      }

      if (orderBy !=  'x' && !orderBy %in% colnames(df)) {
        message('wrong orderBy parameter; set to default `orderBy = "x"`')
        orderBy <- "x"
      }

      if (orderBy == "x") {
        df <- dplyr::mutate(df, x = eval(parse(text=x)))
      }

      df$hover = paste0(
        paste0(df[,"Description"], "\n"),
        paste0("GeneRatio:", as.character(round(df[,"x"],2)), "\n"),
        paste0(size, ": ", as.character(df[,size]), "\n"),
        paste0(colorBy, ": ", as.character(round(df[,colorBy],5)), "\n"),
        df$.sign
      )

      df[,"Description"] = as.character(df[,"Description"])

      if (mode == "Activated") {
        df = df[df$.sign == "activated",]
        trace_hline = FALSE
      } else if (mode == "Suppressed") {
        df = df[df$.sign == "suppressed",]
        trace_hline = FALSE
      } else if (mode == "Both") {
        mode = "Activated (top) - Suppressed (bottom)"
        trace_hline = TRUE
      } else {
        warning("Invalid mode, setting to 'Both' by default")
        mode = "Activated (top) - Suppressed (bottom)"
        trace_hline = TRUE
      }


      fig = plotly::plot_ly(data = df,
                            x = ~x,
                            y = df[,"Description"],
                            size = df[,size],
                            type = "scatter",
                            mode = "markers",
                            marker = list(color = df[,colorBy],
                                          sizemode ='diameter',
                                          opacity = 0.5,
                                          sizeref=1,
                                          colorscale = 'RdBu',
                                          colorbar=list(
                                            title=colorBy
                                          ),
                                          line = list(width = 0),
                                          cmax = max(df[, colorBy]),
                                          cmin = min(df[, colorBy])
                            ),
                            text = df$hover,
                            hoverinfo = "text",
                            width = width,
                            height = height
      )
      fig = fig %>% layout(
        legend= list(itemsizing='constant'),
        title = mode,
        xaxis = list(title = 'GeneRatio'),
        yaxis = list(title =  NA,
                     categoryorder = "array",
                     categoryarray = base::rev(df[,"Description"]))
      )
      if (trace_hline) {
        fig = fig %>% layout(
          shapes = list(hline(showCategory - 0.5))
        )
      }
      print_tm(self$name, "Dot plot completed")
      self$plots$dotplot = fig
    },

    plot_or_dot_plot = function(object = self$tables$go_enrich,
                                x = "GeneRatio",
                                color = "p.adjust",
                                showCategory = self$params$or_dot_plot$showCategory,
                                size = NULL,
                                split = NULL,
                                orderBy="x",
                                width = NULL,
                                height = NULL){

      colorBy <- match.arg(color, c("pvalue", "p.adjust", "qvalue"))
      if (x == "geneRatio" || x == "GeneRatio") {
        x <- "GeneRatio"
        if (is.null(size))
          size <- "Count"
      } else if (x == "count" || x == "Count") {
        x <- "Count"
        if (is.null(size))
          size <- "GeneRatio"
      } else if (is(x, "formula")) {
        x <- as.character(x)[2]
        if (is.null(size))
          size <- "Count"
      } else {
        ## message("invalid x, setting to 'GeneRatio' by default")
        ## x <- "GeneRatio"
        ## size <- "Count"
        if (is.null(size))
          size  <- "Count"
      }

      if (inherits(object, c("enrichResultList", "gseaResultList"))) {
        ldf <- lapply(object, fortify, showCategory=showCategory, split=split)
        df <- dplyr::bind_rows(ldf, .id="category")
        df$category <- factor(df$category, levels=names(object))
      } else {
        # df = get_cp_results(object, showCategory)
        df <- fortify(object, showCategory = showCategory, split=split)
        ## already parsed in fortify
        ## df$GeneRatio <- parse_ratio(df$GeneRatio)
      }

      if (orderBy !=  'x' && !orderBy %in% colnames(df)) {
        message('wrong orderBy parameter; set to default `orderBy = "x"`')
        orderBy <- "x"
      }

      if (orderBy == "x") {
        df <- dplyr::mutate(df, x = eval(parse(text=x)))
      }


      df$hover = paste0(
        paste0(df[,"Description"], "\n"),
        paste0(x, ":", as.character(round(df[,x],2)), "\n"),
        paste0(size, ": ", as.character(df[,size]), "\n"),
        paste0(colorBy, ": ", as.character(round(df[,colorBy],5)), "\n"),
        df$.sign
      )

      df[,"Description"] = as.character(df[,"Description"])



      fig = plotly::plot_ly(data = df,
                            x = df$GeneRatio,
                            y = df[,"Description"],
                            size = df[,size],
                            type = "scatter",
                            mode = "markers",
                            marker = list(color = df[,colorBy],
                                          sizemode ='diameter',
                                          opacity = 0.5,
                                          sizeref=1,
                                          colorscale = 'RdBu',
                                          colorbar=list(
                                            title=colorBy
                                          ),
                                          line = list(width = 0),
                                          cmax = max(df[, colorBy]),
                                          cmin = min(df[, colorBy])
                            ),
                            text = df$hover,
                            hoverinfo = "text",
                            width = width,
                            height = height
      )
      fig = fig %>% layout(
        legend= list(itemsizing='constant'),
        title = mode,
        xaxis = list(title = 'GeneRatio'),
        yaxis = list(title =  NA,
                     categoryorder = "array",
                     categoryarray = base::rev(df[,"Description"]))
      )
      self$plots$or_dotplot = fig

    },

    plot_cnet_plot = function(x = self$tables$gsea_object,
                              showCategory = self$params$cnet_plot$showCategory,
                              displayed_labels = self$params$cnet_plot$displayed_labels,
                              enable_physics = self$params$cnet_plot$enable_physics,
                              context = "gsea") {

      showCategory = as.numeric(showCategory)

      if (context == 'gsea') {
        prot_list = self$tables$gsea_prot_list
      } else if (context == 'ora') {
        prot_list = self$tables$ora_prot_list
      }

      # df = get_cp_results(object = x, showCategory = showCategory)
      geneSets = enrichplot:::extract_geneSets(x, showCategory)
      # df <- fortify(x, showCategory = showCategory)
      # geneSets = geneInCategory(x)
      # geneSets = geneSets[1:min(showCategory, length(geneSets))]

      if (displayed_labels == 'Description') {
        main_nodes = names(geneSets)
      } else if (displayed_labels == 'IDs') {
        main_nodes = x@result$ID[1:showCategory]
      } else if (displayed_labels == 'IDs and Description') {
        main_nodes = paste0(x@result$ID[1:showCategory], '\n', names(geneSets))
      } else {
        stop("displayed_labels must be in ['Description', 'IDs', 'IDs and Description']")
      }
      names(geneSets) = main_nodes


      secondary_nodes = sort(unique(unlist(unname(geneSets))))
      all_nodes = c(main_nodes, secondary_nodes)

      node_table = data.frame(matrix(nrow = length(all_nodes), ncol = 1))
      colnames(node_table) = c("id")
      node_table$id = all_nodes
      node_table$label = all_nodes
      node_table$shape = rep("dot", nrow(node_table))

      feature_values = prot_list[all_nodes,]
      rownames(feature_values) = rownames(node_table)

      node_table = base::cbind(node_table, feature_values)

      normalized_values = scales::rescale(feature_values$log2_fold_change, to = c(0, 1))

      color_gradient = grDevices::colorRampPalette(c("blue", "white", "red"))
      hex_colors = color_gradient(100)[round(normalized_values * 99) + 1]
      hex_colors[which(is.na(hex_colors))] = "#FFD800"
      node_table$color = hex_colors

      source_nodes = c()
      target_nodes = c()
      for (n in main_nodes) {
        target_nodes = c(target_nodes, geneSets[[n]])
        source_nodes = c(source_nodes, rep(n, length(geneSets[[n]])))
      }

      edge_table = data.frame(matrix(nrow = length(target_nodes), ncol = 2))
      colnames(edge_table) = c("from", "to")
      edge_table$from = source_nodes
      edge_table$to = target_nodes
      edge_table$width = rep(1, nrow(edge_table))

      plot = visNetwork::visNetwork(node_table, edge_table)
      plot = visNetwork::visPhysics(plot, enabled = enable_physics)

      if (context == "gsea") {
        self$plots$cnetplot = plot
      } else if (context == "ora") {
        self$plots$or_cnetplot = plot
      }
    },

    plot_ridge_plot = function(x = self$tables$gsea_object,
                               showCategory = self$params$dot_plot$showCategory,
                               fill="p.adjust",
                               core_enrichment = TRUE,
                               orderBy = "NES",
                               decreasing = FALSE,
                               width = NULL,
                               height = NULL) {

      print_tm(self$name, "Ridgeplot initiated")

      if (is.na(showCategory)) {
        base::warning("Invalid showCategory, setting to 30 by default")
        showCategory = 30
      }

      n = showCategory
      if (core_enrichment) {
        gs2id = geneInCategory(x)[seq_len(n)]
      } else {
        gs2id = x@geneSets[x$ID[seq_len(n)]]
      }

      if (x@readable && length(x@gene2Symbol) > 0) {
        id = match(names(x@geneList), names(x@gene2Symbol))
        names(x@geneList) = x@gene2Symbol[id]
      }

      gs2val = lapply(gs2id, function(id) {
        res = x@geneList[id]
        res = res[!is.na(res)]
      })

      nn = names(gs2val)
      i = match(nn, x$ID)
      nn = x$Description[i]

      j = order(x@result[[orderBy]][i], decreasing = decreasing)
      len = sapply(gs2val, length)
      gs2val.df = data.frame(category = rep(nn, times=len),
                             color = rep(x[i, fill], times=len),
                             value = unlist(gs2val))

      colnames(gs2val.df)[2] = fill
      gs2val.df$category = factor(gs2val.df$category, levels=nn[j])

      xdata = na.omit(data.frame(x=gs2val.df$value, group=gs2val.df$category))
      xs = split(xdata$x, xdata$group)
      xs_mask = vapply(xs, length, numeric(1)) > 1
      bws = vapply(xs[xs_mask], bw.nrd0, numeric(1))
      bw = mean(bws, na.rm = TRUE)

      all_traces = levels(gs2val.df$category)
      total_seq = seq(floor(min(gs2val.df$value)),ceiling(max(gs2val.df$value)), by=bw)

      col_values_hex = grDevices::colorRampPalette(RColorBrewer::brewer.pal(n = 9, name = 'YlOrRd'))(length(unique(gs2val.df[,"p.adjust"])))
      col_values = c()
      for (col in col_values_hex){
        col_values = c(col_values, paste0("rgba(",paste(as.vector(col2rgb(col)), collapse = ","), ",0.5)"))
      }
      names(col_values) = seq(1, length(col_values), by = 1)
      col_pvals = sort(unique(gs2val.df[,"p.adjust"]))

      p = plotly::plot_ly(width = width,
                          height = height)
      incr = 0
      for (trace in all_traces) {
        tmp_table = gs2val.df[gs2val.df[,"category"] == trace,]
        fill_value = tmp_table[1, "p.adjust"]
        fill_col = col_values[which(col_pvals == fill_value)]

        tmp_table = as.data.frame(table(cut(tmp_table$value, breaks=total_seq)))
        tmp_table$Var1 = gsub("\\(|]", "", levels(tmp_table$Var1))
        x_values = c()
        for (l in tmp_table$Var1) {
          x_values = c(x_values, mean(as.numeric(stringr::str_split(l, ",")[[1]])))
        }
        tmp_table$Var1 = x_values

        tmp_table$text = paste0(trace, ":\n", "Count: ", tmp_table$Freq, "\n", fill, ": ", fill_value, "\n", "x: ", round(tmp_table$Var1,2))

        tmp_table$Freq = tmp_table$Freq / max(tmp_table$Freq) + incr


        # if ((tmp_table$Freq[nrow(tmp_table)] - incr) > 0) {
        #   tmp_table = base::rbind(tmp_table, c(tmp_table$Var1[tmp_table] +0.5, incr, paste0(trace, ":\n", "Count: ", "0", "\n", fill, ": ", fill_value, "\n", "x: ", round(tmp_table$Var1[1] -1,2))))
        # }
        # if ((tmp_table$Freq[1] - incr) > 0) {
        #   tmp_table = rbind(c(tmp_table$Var1[1] -0.5, incr, paste0(trace, ":\n", "Count: ", "0", "\n", fill, ": ", fill_value, "\n", "x: ", round(tmp_table$Var1[1] -1,2))),
        #                     tmp_table)
        # }



        p = add_trace(p,
                      line = list(
                        color = "#FFFFFF",
                        width = 0.1
                      ),
                      mode = "lines",
                      type = "scatter",
                      x = c(0, max(gs2val.df$value)),
                      y = c(incr-0.01, incr-0.01),
                      legendgroup=0,
                      showlegend = F)

        incr = incr + 1

        p = add_trace(p,
                      fill = "tonexty",
                      line = list(color = "#000000",
                                  width = 0.5,
                                  shape = "spline",
                                  smoothing = 1.3),
                      mode = "lines",
                      type = "scatter",
                      x=tmp_table$Var1,
                      y=tmp_table$Freq,
                      name = trace,
                      fillcolor = fill_col,
                      text = tmp_table$text,
                      hoverinfo = "text",
                      legendgroup=0,
                      showlegend = F)

      }

      p = add_trace(p,
                    x = col_pvals,
                    y = col_pvals,
                    type = "scatter",
                    mode = "markers",
                    marker = list(
                      color = col_pvals,
                      colorscale = "YlOrRd",
                      colorbar=list(title = fill),
                      size = 1,
                      opacity = 0.1),
                    legendgroup=0,
                    showlegend = F
      )


      p = layout(p ,
                 showlegend = T,
                 yaxis = list(
                   type = "linear",
                   range = c(0, length(all_traces)),
                   ticklen = 4,
                   showgrid = TRUE,
                   showline = FALSE,
                   ticktext = all_traces,
                   tickvals = seq(from = 0, to = length(all_traces)-1, by = 1),
                   zeroline = FALSE,
                   gridcolor = "rgb(255,255,255)",
                   gridwidth = 1
                 ),
                 xaxis = list(title = "Log2(fold change)"))

      self$plots$ridgeplot = p
    },

    plot_emap_plot = function(x = self$tables$gsea_object,
                              showCategory = self$params$or_emap_plot$showCategory,
                              color = self$params$or_emap_plot$color,
                              size = self$params$or_emap_plot$size,
                              score_threshold = self$params$or_emap_plot$score_threshold,
                              similarity_score = self$params$or_emap_plot$similarity_score,
                              edge_magnifier = self$params$or_emap_plot$edge_magnifier,
                              node_magnifier = self$params$or_emap_plot$node_magnifier,
                              enable_physics = self$params$or_emap_plot$enable_physics,
                              context = "gsea") {
      # Format data
      showCategory = as.numeric(showCategory)
      score_threshold = as.numeric(score_threshold)
      edge_magnifier = as.numeric(edge_magnifier)
      node_magnifier = as.numeric(node_magnifier)

      # check if showCategory appropriate
      if (showCategory > nrow(x@result)) {
        showCategory = nrow(x@result)
      }

      # Adding data based on GSEA or ORA
      if (context == 'gsea') {
        total_count = x@result$setSize
        count = lapply(x@result$core_enrichment, function(x) {
          elements = unlist(strsplit(x, "/"))
          length(elements)
        })
        count = unlist(count)
        x@result$Count = count
        x@result$total_count = total_count
        x@result$gene_ratio = round(count/total_count, 2)
      } else if (context == 'or') {
        total_count = base::strsplit(x@result$GeneRatio, '/')
        total_count = as.numeric(sapply(total_count, "[[", 2))
        x@result$total_count = total_count
        x@result$gene_ratio = round(x@result$Count / x@result$total_count, 2)
      }


      # Calculate similarities
      x = enrichplot::pairwise_termsim(x= x,
                                       method = similarity_score,
                                       semData = NULL,
                                       showCategory = showCategory)

      # Get the igraph object
      g = enrichplot:::get_igraph(x=x,
                                  nCategory=showCategory,
                                  color=color,
                                  cex_line=edge_magnifier,
                                  min_edge=score_threshold)


      # Extract data from the igraph object
      edge_table = igraph::as_data_frame(g, what = "edges")
      if (length(edge_table) > 0) {
        edge_table$color = "gray"
      }
      node_table = igraph::as_data_frame(g, what = "vertices")
      node_table = cbind(node_table$name, node_table)
      colnames(node_table) = c("id", "label", "size", "color_values")
      node_table$size = x@result[[size]][1:showCategory]
      node_table$shape = "dot"
      rownames(node_table) = 1:nrow(node_table)
      node_table$size = node_table$size * node_magnifier

      # Setting the color gradient
      normalized_values = scales::rescale(node_table$color_values , to = c(0, 1))
      color_gradient = grDevices::colorRampPalette(c("red", "white", "blue"))
      hex_colors = color_gradient(100)[round(normalized_values * 99) + 1]
      node_table$color = hex_colors

      # Produce the network object
      plot = visNetwork::visNetwork(node_table, edge_table)
      plot = visNetwork::visPhysics(plot, enabled = enable_physics)

      ### Store the network object
      if (context == "gsea") {
        self$plots$emap_plot = plot
      } else if (context == "or") {
        self$plots$or_emap_plot = plot
      }
    },

    plot_or_bar_plot = function(object = self$tables$go_enrich,
                                x = self$params$or_bar_plot$x,
                                color = self$params$or_bar_plot$color,
                                showCategory = self$params$or_bar_plot$showCategory,
                                width = NULL,
                                height = NULL) {

      colorBy = match.arg(color, c("pvalue", "p.adjust", "qvalue"))
      if (x == "geneRatio" || x == "GeneRatio") {
        x = "GeneRatio"
      } else if (x == "count" || x == "Count") {
        x = "Count"
      }

      # df = get_cp_results(object, showCategory)
      df = fortify(object, showCategory=showCategory, by=x)

      fig = plotly::plot_ly(df,
                            x = df[,x],
                            y = df$Description,
                            type = 'bar',
                            orientation = 'h',
                            marker = list(
                              colorscale = list(c(0,1), c("red", "blue")),
                              colorbar = list(title = "p.adjust"),
                              color = ~p.adjust),
                            width = width,
                            height = height) %>%
        layout(xaxis = list(title = 'Count')
        )
      self$plots$or_barplot = fig
    }
    #------------------------------------------------------------------ END ----
  )
)
